/* Re:Live - Core Logic & Visuals 
  Handles the HTML5 Canvas drawing for the "sketchy" paths and the interaction logic.
*/

const canvas = document.getElementById('visuals-canvas');
const ctx = canvas.getContext('2d');
const uiLayer = document.getElementById('ui-layer');

// State
let paths = []; // Stores the geometric data for the ribbons
let particles = []; // For the "Roll" orb animation
let animationId;
let isRolling = false;

// Configuration for the "Sketch" style
const CONFIG = {
    coreSize: 40,
    ribbonWidth: 30,
    sketchLines: 5, // How many "pencil strokes" per ribbon
    sketchJitter: 2, // Randomness in the lines
    color: 'rgba(220, 220, 220, 0.8)'
};

// Initialize
window.addEventListener('resize', resizeCanvas);
window.addEventListener('load', () => {
    resizeCanvas();
    setupInteractions();
    animate();
});

function resizeCanvas() {
    canvas.width = window.innerWidth;
    canvas.height = window.innerHeight;
    generatePaths(); // Regenerate paths when screen changes size
}

/* -------------------------------------------------------
  PATH GENERATION
  Calculates Bezier curves from the center Core to each Button.
  -------------------------------------------------------
*/
function generatePaths() {
    paths = [];
    const centerX = canvas.width / 2;
    const centerY = canvas.height / 2;

    // Find all choice buttons
    const buttons = document.querySelectorAll('.choice-node');

    buttons.forEach(btn => {
        const rect = btn.getBoundingClientRect();
        
        // Determine where the path connects to the button
        // If button is on the left, connect to its right side.
        // If button is on the right, connect to its left side.
        let targetX, targetY;
        const isLeft = rect.left < window.innerWidth / 2;

        if (isLeft) {
            targetX = rect.right;
            targetY = rect.top + rect.height / 2;
        } else {
            targetX = rect.left;
            targetY = rect.top + rect.height / 2;
        }

        // Create random control points for the curve
        // This creates the "variation" you asked for.
        // We offset the control point randomly to make curves twist differently.
        const cp1X = centerX + (Math.random() - 0.5) * 200;
        const cp1Y = centerY + (Math.random() - 0.5) * 400;
        const cp2X = targetX + (isLeft ? 100 : -100); // Push curve out slightly
        const cp2Y = targetY;

        paths.push({
            id: btn.id,
            startX: centerX,
            startY: centerY,
            cp1X, cp1Y,
            cp2X, cp2Y,
            endX: targetX,
            endY: targetY,
            isHovered: false,
            isLocked: btn.classList.contains('locked')
        });
    });
}

/* -------------------------------------------------------
  INTERACTION
  -------------------------------------------------------
*/
function setupInteractions() {
    const buttons = document.querySelectorAll('.choice-node');

    buttons.forEach(btn => {
        // Hover Effects
        btn.addEventListener('mouseenter', () => {
            const path = paths.find(p => p.id === btn.id);
            if (path) path.isHovered = true;
        });

        btn.addEventListener('mouseleave', () => {
            const path = paths.find(p => p.id === btn.id);
            if (path) path.isHovered = false;
        });

        // Click / Roll Logic
        btn.addEventListener('click', (e) => {
            if (btn.classList.contains('locked')) return;
            if (isRolling) return;

            startRoll(btn.id);
        });
    });
}

function startRoll(choiceId) {
    isRolling = true;
    
    // Disable UI interaction visually
    document.body.style.cursor = 'wait';
    
    const path = paths.find(p => p.id === choiceId);
    if (!path) return;

    // Spawn the "Orb"
    particles = [{
        t: 0, // Progress along the curve (0 to 1)
        speed: 0.015,
        path: path
    }];
}

/* -------------------------------------------------------
  RENDERING LOOP
  -------------------------------------------------------
*/
function animate() {
    ctx.clearRect(0, 0, canvas.width, canvas.height);

    drawCore();
    drawPaths();
    drawParticles();

    requestAnimationFrame(animate);
}

function drawCore() {
    const cx = canvas.width / 2;
    const cy = canvas.height / 2;

    // Draw the "Singularity" (Black hole with glow)
    
    // Outer Glow
    const gradient = ctx.createRadialGradient(cx, cy, 10, cx, cy, 60);
    gradient.addColorStop(0, 'rgba(255, 255, 255, 0.8)');
    gradient.addColorStop(0.2, 'rgba(200, 200, 200, 0.2)');
    gradient.addColorStop(1, 'rgba(0, 0, 0, 0)');
    
    ctx.fillStyle = gradient;
    ctx.beginPath();
    ctx.arc(cx, cy, 60, 0, Math.PI * 2);
    ctx.fill();

    // Inner Void (jittery scribbles)
    ctx.strokeStyle = '#fff';
    ctx.lineWidth = 1;
    ctx.beginPath();
    for (let i = 0; i < 10; i++) {
        ctx.arc(
            cx + (Math.random() - 0.5) * 5, 
            cy + (Math.random() - 0.5) * 5, 
            15, 0, Math.PI * 2
        );
    }
    ctx.stroke();
}

function drawPaths() {
    paths.forEach(path => {
        // Set style based on state
        if (path.isLocked) {
            ctx.strokeStyle = 'rgba(100, 100, 100, 0.2)'; // Dim for locked
        } else if (path.isHovered) {
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.9)'; // Bright for hover
        } else {
            ctx.strokeStyle = 'rgba(200, 200, 200, 0.4)'; // Normal
        }

        // Draw multiple strokes to simulate "sketchiness"
        for (let i = 0; i < CONFIG.sketchLines; i++) {
            ctx.lineWidth = Math.random() * 2 + 0.5;
            ctx.beginPath();
            
            // Add Jitter to control points for that hand-drawn look
            const j = CONFIG.sketchJitter;
            const cp1X_j = path.cp1X + (Math.random() - 0.5) * j * 10;
            const cp1Y_j = path.cp1Y + (Math.random() - 0.5) * j * 10;
            
            ctx.moveTo(path.startX, path.startY);
            ctx.bezierCurveTo(
                cp1X_j, cp1Y_j,
                path.cp2X, path.cp2Y,
                path.endX, path.endY
            );
            ctx.stroke();
        }
        
        // Draw the flat "Ribbon" look (Optional fill)
        // To make it look like a flat path, we can draw a faint wide line underneath
        if (!path.isLocked) {
            ctx.lineWidth = 20;
            ctx.strokeStyle = path.isHovered ? 'rgba(255,255,255,0.05)' : 'rgba(255,255,255,0.02)';
            ctx.beginPath();
            ctx.moveTo(path.startX, path.startY);
            ctx.bezierCurveTo(path.cp1X, path.cp1Y, path.cp2X, path.cp2Y, path.endX, path.endY);
            ctx.stroke();
        }
    });
}

function drawParticles() {
    if (particles.length === 0) return;

    particles.forEach((p, index) => {
        // Move particle
        p.t += p.speed;

        if (p.t >= 1) {
            p.t = 1;
            // Animation Complete Logic
            completeRoll(p.path);
        }

        // Calculate position on Bezier Curve
        // Standard cubic bezier formula: B(t) = (1-t)^3 P0 + 3(1-t)^2 t P1 + 3(1-t) t^2 P2 + t^3 P3
        const t = p.t;
        const mt = 1 - t;
        
        const x = (mt * mt * mt * p.path.startX) +
                  (3 * mt * mt * t * p.path.cp1X) +
                  (3 * mt * t * t * p.path.cp2X) +
                  (t * t * t * p.path.endX);
                  
        const y = (mt * mt * mt * p.path.startY) +
                  (3 * mt * mt * t * p.path.cp1Y) +
                  (3 * mt * t * t * p.path.cp2Y) +
                  (t * t * t * p.path.endY);

        // Draw Orb
        // Glow
        const grad = ctx.createRadialGradient(x, y, 2, x, y, 20);
        grad.addColorStop(0, 'white');
        grad.addColorStop(0.4, 'cyan'); // "Glowing Orb" color
        grad.addColorStop(1, 'transparent');
        
        ctx.fillStyle = grad;
        ctx.beginPath();
        ctx.arc(x, y, 20, 0, Math.PI * 2);
        ctx.fill();
        
        // Core of Orb
        ctx.fillStyle = '#fff';
        ctx.beginPath();
        ctx.arc(x, y, 4, 0, Math.PI * 2);
        ctx.fill();
    });
}

function completeRoll(path) {
    // This function runs when the orb hits the destination
    isRolling = false;
    document.body.style.cursor = 'default';
    particles = []; // clear particles

    // Simple feedback for now - in a real game, this would load the next scene
    alert(`Selected: Path for ${path.id}. The orb has spoken.`);
    
    // Optional: Regenerate paths to simulate "Next Scenario"
    generatePaths();
}
